(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage[$CommonPackage];
Average;
ComplexContourNIntegrate;
ComplexContourIntegrate;
CircleNIntegrate;
JacobiQuadratureWeights;
LaguerreQuadratureWeights;
HermiteQuadratureWeights;
NewtonMethod;
NewtonInverse;
JacobiMatrix;
ToMachineNumber;
MExp;
Begin["Private`"];


ToMachineNumber[x_?((Abs[#]<=$MinMachineNumber)&)]:=Nwp[0];ToMachineNumber[x_?(Abs[#]>=$MaxMachineNumber&)]:=Sign[x] $MaxMachineNumber;
ToMachineNumber[x_]:=x//Nwp;
MExp[x_]:=ToMachineNumber@Exp[x];


JacobiMatrix[n_,\[Alpha]_,\[Beta]_]:=Module[{J,i,j,\[CapitalLambda],V},
SparseArray[{{i_,i_}:>\[Alpha][i],{i_,j_}/;j==i-1:>\[Beta][j],{i_,j_}/;j==i+1:>\[Beta][i]},{n,n}]
];



GolubWelschWeights[n_,\[Mu]0_,\[Alpha]_,\[Beta]_]:=Module[{J,i,j,\[CapitalLambda],V},
{\[CapitalLambda],V}=Eigensystem[Nwp[JacobiMatrix[n,\[Alpha],\[Beta]]]];
Thread[{\[CapitalLambda],Map[\[Mu]0 First[#]^2/Norm[#]^2&,V]}]
];


Average[l_]:=Apply[Plus,l]/Length[l]


NewtonQuadrature[f_,h_]:=Average[Table[f,h]];


WeightedSum[f_,nds_]:=Apply[Plus,Map[f[#[[1]]]#[[2]]&,nds]]


GaussQuadrature[f_,n_,a_:0,b_:1]:=WeightedSum[f,GaussianQuadratureWeights[n,a,b]]


LaguerreQuadratureWeights[n_,a_:0]:=LaguerreQuadratureWeights[n,a]=Module[{\[Alpha],\[Beta]},
\[Beta][j_]:=Sqrt[j(j+a)];\[Alpha][j_]:=a-1+ 2j;
GolubWelschWeights[n,Gamma[a+1],\[Alpha],\[Beta]]
]


JacobiQuadratureWeights[n_,a_,b_]:=JacobiQuadratureWeights[n,a,b]=Module[{A,B,CC,\[Alpha],\[Beta]},
A[j_]:=((2j+a+b+1)(2j+a+b+2))/(2(j+1)(j+a+b+1));
B[j_]:=((a^2-b^2)(2j+a+b+1))/(2(j+1)(j+a+b+1)(2j+a+b));
CC[j_]:=((j+a)(j+b)(2j+a+b+2))/((j+1)(j+a+b+1)(2j+a+b));

\[Alpha][j_]:=-(B[j-1]/A[j-1]);\[Beta][j_]:=Sqrt[CC[j]/(A[j-1]A[j])];

GolubWelschWeights[n,Hypergeometric2F1[1,-a,2+b,-1]/(1+b)+Hypergeometric2F1[1,-b,2+a,-1]/(1+a),\[Alpha],\[Beta]]

];


HermiteQuadratureWeights[n_]:=HermiteQuadratureWeights[n,2];
HermiteQuadratureWeights[n_,2]:=HermiteQuadratureWeights[n,2]=Module[{\[Alpha],\[Beta]},
\[Beta][j_]:=Sqrt[j/2];\[Alpha][j_]:=0;
GolubWelschWeights[n,Sqrt[\[Pi]],\[Alpha],\[Beta]]//Sort
];


With[{alpha3={.5054680881560892780320687,.7226348664833369136115949,.8692882757695939617175302,.9749922051523184735146231,1.0611698144195765789639876,1.1351119261170298708945448,1.2004347677717856082662605,1.2592936519456071245968346,1.3130898807554168480269836,1.3627924506244114151019191,1.4091030992819566485213497,1.4525484726755266305505258,1.4935352085725111723524419,1.5323846590914736712001735,1.5693557379424343643277852,1.6046604955043460034394741,1.6384750570513262020646310,1.6709475019934206493075227,1.7022036653732748948851538,1.7323514920163192587959729,1.7614843599411278944323189,1.7896836552598686011526193,1.8170207940047283169206117,1.8435588288855982291404916,1.8693537401547435849412321,1.8944554829872121478593413,1.9189088450079165692997670,1.9427541542117511537121345,1.9660278678431228735744558,1.9887630657066679067660484,2.0109898661170686275588552,2.0327357787459252440068063,2.0540260056283937457286733,2.0748836992988052749599186,2.0953301852523293787989637,2.1153851545487862718411964,2.1350668312900374970798054,2.1543921188440694053802017,2.1733767280049305088171258,2.1920352897290754271949821,2.2103814546458834302585619,2.2284279811806444869255955,2.2461868138348418992436780,2.2636691529277229688974317,2.2808855169045112642467285,2.2978457981520024612237463,2.3145593131252544025289251,2.3310348474745180754114049,2.3472806967653819948555278,2.3633047033040489890146327},
beta3={.8929795115692492112185643,.1177841857632231864536461,.1697400428612904305233045,.2181674313917282684498784,.2628303463419099355990120,.3042143899457009645271018,.3430590355702954101407096,.3798748839163785458933576,.4150201477139501999281029,.4487573835433915654532293,.4812855572606512482672936,.5127596611666888810592785,.5433032520097659153985869,.5730167576776715109021154,.6019831630206301079400346,.6302720150349986348356849,.6579423158085268102505151,.6850446584837777832019632,.7116228350819671235574493,.7377150676438892099574683,.7633549653885194071672751,.7885722790606476256467780,.8133935027639770778931450,.8378423594575769778955116,.8619401965582968038212593,.8857063112598238521655051,.9091582203070667486452115,.9323118854387871595746922,.9551819031252129452409242,.9777816653066255024361222,1.0001234963959086036599283,1.0222187707123455093611931,1.0440780136736938652308541,1.0657109894232372943541356,1.0871267770608308312347968,1.1083338372474325967251584,1.1293400706358236186168156,1.1501528693272423743378424,1.1707791623502936677842499,1.1912254559939736324179292,1.2114978696927702061955152,1.2316021680522332237095776,1.2515437895132654595070362,1.2713278720788475528440202,1.2909592764649785321691512,1.3104426069859223403108086,1.3297822304405186882921264,1.3489822932298414138380496}},





FreudQuadratureWeights[n_]:=FreudQuadratureWeights[n]=Module[{A,B,CC,\[Alpha],\[Beta]},
A[i_]:=1;B[i_]:=-alpha3[[i]];CC[i_]:=beta3[[i+1]];
\[Alpha][j_]:=-(B[j]/A[j]);\[Beta][j_]:=Sqrt[CC[j]/(A[j-1]A[j])];
GolubWelschWeights[n,Gamma[4/3] ,\[Alpha],\[Beta]]];
]


LegendreQuadrature[f_,n_,a_:0,b_:1]:=Plus@@Map[f[#[[1]]]#[[2]]&,GaussianQuadratureWeights[n,a,b]];
LegendreQuadrature[f_,n_,a_,b_,prec_]:=Plus@@Map[f[#[[1]]]#[[2]]&,GaussianQuadratureWeights[n,a,b,prec]];


LobattoPoints[2,a_:-1,b_:1]:={a,b};
LobattoPoints[n_,a_:-1,b_:1,prec_:$MachinePrecision]:=LobattoPoints[n,a,b,prec]=Nwp[Join[{a,b},(b+a)/2+(b-a)/2 Map[#[[2]]&,Apply[List,Roots[0==D[LegendreP[n-1,x],x],x]]]],prec]//Sort;
LobattoPoints[n_,a_:-1,b_:1]:=LobattoPoints[n,a,b]=Nwp[Join[{a,b},(b+a)/2+(b-a)/2 Map[#[[2]]&,Apply[List,Roots[0==D[LegendreP[n-1,x],x],x]]]]]//Sort;
LobattoPoints[3,a_:-1,b_:1]:=LobattoPoints[3,a,b]=Nwp[Join[{a,b},{(b+a)/2+(b-a)/2 Apply[List,Roots[0==D[LegendreP[2,x],x],x]][[2]]}]]//Sort;
LobattoWeights[n_,a_:-1,b_:1]:=LobattoWeights[n,a,b]=Thread[{LobattoPoints[n,a,b],Map[Function[x,(b-a)/(n(n-1)LegendreP[n-1,x]^2)],LobattoPoints[n,-1,1]]}]//N//Chop//Sort;
LobattoWeights[n_,a_:-1,b_:1,prec_:$MachinePrecision]:=LobattoWeights[n,a,b,prec]=Nwp[Thread[{LobattoPoints[n,a,b,prec],Map[Function[x,(b-a)/(n(n-1)LegendreP[n-1,x]^2)],LobattoPoints[n,-1,1,prec]]}],prec]//Chop//Sort;


SetAttributes[WeightIntegrate,HoldFirst];
WeightIntegrate[h_,x_,weights_]:=Module[{f},
f[y_]:=ReleaseHold[Hold[h]/.x->y];
Plus@@Map[f[#[[1]]]#[[2]]&,weights]
]


SetAttributes[GIntegrate,HoldFirst];
GIntegrate[h_,{x_,a_,b_,n_}]:=WeightIntegrate[h,x,GaussianQuadratureWeights[n,a,b]];
SetAttributes[LIntegrate,HoldFirst];
LIntegrate[h_,{x_,a_,b_,n_}]:=WeightIntegrate[h,x,LobattoWeights[n,a,b]];
SetAttributes[HermiteIntegrate,HoldFirst];
HermiteIntegrate[h_,{x_,n_},r_:2]:=WeightIntegrate[h,x,HermiteQuadratureWeights[n,r]];
GIntegrate[h_,{x_,a_,b_,n_},{y_,a2_,b2_,n2_}]:=GIntegrate[GIntegrate[h,{x,a,b,n}],{y,a2,b2,n2}];


SetAttributes[LaguerreIntegrate,HoldFirst];
LaguerreIntegrate[h_,{x_,a_,n_},\[Alpha]_:0]:=Module[{f},
f[y_]:=ReleaseHold[Hold[h]/.x->y+a];
Exp[-a]Plus@@Map[f[#[[1]]]#[[2]]&,LaguerreQuadratureWeights[n,\[Alpha]]]
];
LaguerreIntegrate[h_,{x_,a_,n_},{y_,b_,m_}]:=
LaguerreIntegrate[LaguerreIntegrate[h,{x,a,n}],{y,b,m}]



GIntegrateLimited[h_,{x_,a_,b_,n_}]:=Module[{f},
f[y_]:=Limit[h,x->y];
LegendreQuadrature[f,n,a,b]
]


TIntegrate[h_,{x_,a_,b_,m_}]:=Module[{},
(b-a)/m(((h/.x->Nwp[a])+(h/.x->Nwp[b]))/2+Sum[h/.x->Nwp[a+j (b-a)/m],{j,1,m-1}])]


ConstructTInnerProduct[m_,a_,b_][f_,g_]:=TIntegrate[f[t] Conjugate[g[t]],{t,a,b,m}]


ComplexContourNIntegrate[h_,yv_,tv_,opts___]:=Module[{hl},
hl = D[Last[yv],First[tv]](h/.First[yv]->Last[yv]);
NIntegrate[hl,tv,opts]];
ComplexContourIntegrate[h_,yv_,tv_,opts___]:=Module[{hl},
hl = D[Last[yv],First[tv]](h/.First[yv]->Last[yv]);
Integrate[hl,tv,opts]];
CircleNIntegrate[h_,{z_,a_,r_},opts___]:=Module[{t},ComplexContourNIntegrate[h,{z,a+r Exp[I t]},{t,-\[Pi],\[Pi]},opts]];
CircleNIntegrate[h_,{z_,r_},opts___]:=CircleNIntegrate[h,{z,0,r},opts];
CircleNIntegrate[h_,z_,opts___]:=CircleNIntegrate[h,{z,0,1},opts];


NewtonMethod[f_,fp_,x0_,OptionsPattern[{InterpolationPrecision->100 $MachineTolerance,MaxIterations->25}]]:=Module[{ret,retold,maxiter},
	retold=x0+10;
	ret=x0;
	maxiter=0;
While[Norm[f[ret]]>OptionValue[InterpolationPrecision],
	If[maxiter>OptionValue[MaxIterations],
		Message[$IterationLimit::itlim,OptionValue[MaxIterations]];
		Return[Null];
];

	retold=ret;
	ret=ret-f[ret]/fp[ret];
	maxiter++;
];
Table[
	retold=ret;
	ret=ret-f[ret]/fp[ret];
,{3}];
ret];
NewtonMethod[f_,x0_,opts:OptionsPattern[{InterpolationPrecision->100 $MachineTolerance,MaxIterations->25}]]:=NewtonMethod[f,f',x0,opts];
NewtonInverse[f_,pt_,opts:OptionsPattern[{InterpolationPrecision->100 $MachineTolerance,MaxIterations->25}]]:=NewtonMethod[f[#]-pt&,pt,opts];
NewtonInverse[f_,pt_,x0_,opts:OptionsPattern[{InterpolationPrecision->100 $MachineTolerance,MaxIterations->25}]]:=
NewtonMethod[f[#]-pt&,f',x0,opts];
NewtonInverse[f_,fp_,pt_,x0_,opts:OptionsPattern[{InterpolationPrecision->100 $MachineTolerance,MaxIterations->25}]]:=
NewtonMethod[f[#]-pt&,fp,x0,opts];


SecantMethod[f_,x0_,x1_]:=Module[{ret},
	ret[0]=x0;
	ret[1]=x1;
	ret[n_]:=ret[n]=ret[n-1]-(ret[n-1]-ret[n-2])/(f[ret[n-1]]-f[ret[n-2]]) f[ret[n-1]];
ret];


BisectionMethod[f_,x0_,x1_]:=Module[{ret,avg},
ret[0]={x0,x1};
avg[n_]:=avg[n]=Average[ret[n]];
ret[n_]:=ret[n]=If[f[First[ret[n-1]]]<f[Last[ret[n-1]]],
{First[ret[n-1]],avg[n-1]},{avg[n-1],Last[ret[n-1]]}
];
ret
]



End[];
EndPackage[];
