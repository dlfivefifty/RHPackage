(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["RiemannHilbert`",{"RiemannHilbert`Common`"}];


Cauchy::usage="Cauchy[f,z] evaluates the Cauchy transform \!\(\*FractionBox[\(1\), \(2\\\ \[Pi]\[NonBreakingSpace]I\)]\)\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - z\)]\)\[DifferentialD]t of an IFun f at a complex point z. Cauchy[ifunlist,z] evaluates the sum of the Cauchy transform of each element of ifunlist. Cauchy[\[PlusMinus]1,f,x] evaluates the left/right limit of Cauchy[f,x] for x on the domain of f. Cauchy[\[PlusMinus]1,flist] for CauchyBoundedQ[flist] true evaluates the Cauchy transform of flist on the points of flist, returning another list of IFuns.";
Hilbert::usage="Hilbert[f,x] evaluates the Hilbert transform \!\(\*FractionBox[\(1\), \(\[Pi]\)]\)PV\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - x\)]\)\[DifferentialD]t of an IFun f at a point x on Domain[f].";

CauchyInverse;
CauchyInverseBasis;
HilbertInverse;

CauchyMatrix;
CauchyS;

FPCauchyBasis;
CauchyBasis;
CauchyBasisS;
CauchyMatrix;
FastCauchy;
Stieljes;
CauchyInverseInverseFunction;
CauchyInverseFunction;
StieljesInverseFunction;
CauchyInverseIntegral;
CauchyIntegral;
CauchyIntegralS;
CauchyD;
CauchyInverseD;
StieljesD;

BoundedCauchyInverseD;


Begin["`Private`"];


CauchyInverse[lf_LFun,z_List]:=CauchyInverse[lf,#]&/@z;
Cauchy[lf_LFun,z_List]:=Cauchy[lf,#]&/@z;
Cauchy[s_?SignQ,lf_LFun,z_List]:=Cauchy[s,lf,#]&/@z;


CauchyS[-1,lf_LFun?UnitCircleFunQ,z_?InfinityQ]:=0;


CauchyS[+1,lf_LFun?UnitCircleFunQ,z_]:=NonNegativeEvaluate[lf,z];
CauchyS[-1,lf_LFun?UnitCircleFunQ,z_]:=-NegativeEvaluate[lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]<=1.&)]:=CauchyS[+1,lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]>1.&)]:=CauchyS[-1,lf,z];
Cauchy[s_?SignQ,lf_LFun?UnitCircleFunQ,_?InfinityQ]:=0;
Cauchy[s_?SignQ,lf_LFun?UnitCircleFunQ,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyS[s,lf,z];
Cauchy[s_?SignQ,lf_LFun?UnitCircleFunQ,z_?ScalarQ]:=Cauchy[lf,z];

Cauchy[f:LFun[_,_Curve],z_?ScalarQ]:=Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[s_?SignQ,f:LFun[_,_Curve],z_?ScalarQ]/;DomainMemberQ[f,z]:=Total[Cauchy[s,f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[lf_LFun,z_?ScalarQ]:=Cauchy[lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Cauchy[s_?SignQ,lf_LFun,z_?ScalarQ]:=Cauchy[s,lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Hilbert[lf_LFun,z_?ScalarQ]:=I (Cauchy[+1,lf,z]+Cauchy[-1,lf,z]);
Stieljes[f_,z_]:=-2 \[Pi] I Cauchy[f,z];
StieljesD[f_,z_]:=-2 \[Pi] I CauchyD[f,z];
StieljesD[k_][f_,z_]:=-2 \[Pi] I CauchyD[k][f,z];


CauchyInverse[+1,lf_LFun,z_]:=Cauchy[+1,lf,z];
CauchyInverse[-1,lf_LFun,z_]:=-Cauchy[-1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]<=1.:=CauchyInverse[+1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]>1.:=CauchyInverse[-1,lf,z];

HilbertInverse[lf_LFun,z_]:=-I (CauchyInverse[+1,lf,z]-CauchyInverse[-1,lf,z]);


Cauchy[+1,lf_LFun?UnitCircleFunQ]:=NonNegativePart[lf];
Cauchy[-1,lf_LFun?UnitCircleFunQ]:=-NegativePart[lf];

Cauchy[s_?SignQ,f:LFun[_,_Curve]]:=LFun[Cauchy[s,f,f//Points],f//Domain];

Cauchy[s_?SignQ,lf_LFun]:=LFun[Cauchy[s,lf//ToUnitCircle]//Values,lf//Domain]-ToArrayFun[Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]] OneFun[lf]];
Hilbert[lf_LFun]:=I (Cauchy[+1,lf]+Cauchy[-1,lf]);

CauchyInverse[+1,lf_LFun]:=Cauchy[+1,lf];
CauchyInverse[-1,lf_LFun]:=-Cauchy[-1,lf];

HilbertInverse[lf_LFun]:=-I (CauchyInverse[+1,lf]-CauchyInverse[-1,lf]);

Cauchy[s_?SignQ,f_LFun,f_LFun]:=Cauchy[s,f];
Cauchy[s_?SignQ,f_LFun,g_?FunQ]:=Head[g][Cauchy[f,g//Points],g//Domain];
Cauchy[s_?SignQ,f:{__LFun},g_?FunQ]:=Cauchy[s,#,g]&/@f//Total;
Cauchy[s_?SignQ,f:{__LFun},g:{__LFun}]:=Cauchy[s,f,#]&/@g;

Cauchy[s_?SignQ,f_List]:=Cauchy[s,f,f];



CauchyBasis[_?SignQ,_Integer,_?InfinityQ]:=0;
CauchyBasisS[_?SignQ,_,_Integer,_?InfinityQ]:=0;



CauchyBasis[f_?FunQ,k_,x_]:=CauchyBasis[f//Domain,k,x];
CauchyBasis[s_?SignQ,f_?FunQ,k_,x_]:=CauchyBasis[s,f//Domain,k,x];

CauchyBasisS[f_?FunQ,k_,x_]:=CauchyBasisS[f//Domain,k,x];
CauchyBasisS[s_?SignQ,f_?FunQ,k_,x_]:=CauchyBasisS[s,f//Domain,k,x];

CauchyBasisS[+1,UnitCircle,k_?Negative,z_]:=0 z;
CauchyBasisS[-1,UnitCircle,k_?Negative,z_]:=-z^k;
CauchyBasisS[+1,UnitCircle,0,z_List]:=OneVector[Length[z]];
CauchyBasisS[+1,UnitCircle,0,z_]:=1;
CauchyBasisS[+1,UnitCircle,k_?NonNegative,z_]:=z^k;
CauchyBasisS[-1,UnitCircle,k_?NonNegative,z_]:=0 z;


CauchyBasis[d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[d,k,#]&/@z;
CauchyBasis[s_?SignQ,d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[s,d,k,#]&/@z;


CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]<=1.&)]:=CauchyBasisS[+1,UnitCircle,k,z];
CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]>1.&)]:=CauchyBasisS[-1,UnitCircle,k,z];

CauchyBasis[s_?SignQ,UnitCircle,k_Integer,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyBasisS[s,UnitCircle,k,z];
CauchyBasis[s_?SignQ,UnitCircle,k_Integer,z_]:=CauchyBasis[UnitCircle,k,z];


CauchyBasis[d:Curve[_LFun],0,z_]:=Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],0,z_]:=Total[CauchyBasis[s,UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[s_?SignQ,d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[s,UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],i_Integer;;j_Integer,z_List]:=((Total/@CauchyBasis[s,UnitCircle,i;;j,#])&/@ComplexMapToCircle[d,z]//Transpose)-Count[ComplexMapToCircle[d,10^18],_?(Abs[#]<1&)]  ToList[BasisShiftList[i;;j,0]];


CauchyBasis[f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasis[s_?SignQ,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasisS[s_?SignQ,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasisS[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];


CauchyBasisS[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasisS[s,d,k,z],{k,i,j}]];
CauchyBasis[d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[d,k,z],{k,i,j}]];
CauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[s,d,k,z],{k,i,j}]];



CauchyInverseBasis[_?SignQ,_Integer,_?InfinityQ]:=0;
CauchyInverseBasisS[_?SignQ,_,_Integer,_?InfinityQ]:=0;



CauchyInverseBasis[f_?FunQ,k_,x_]:=CauchyInverseBasis[f//Domain,k,x];
CauchyInverseBasis[s_?SignQ,f_?FunQ,k_,x_]:=CauchyInverseBasis[s,f//Domain,k,x];

CauchyInverseBasisS[f_?FunQ,k_,x_]:=CauchyInverseBasisS[f//Domain,k,x];
CauchyInverseBasisS[s_?SignQ,f_?FunQ,k_,x_]:=CauchyInverseBasisS[s,f//Domain,k,x];

CauchyInverseBasisS[s_?SignQ,lf_?CircleDomainQ,k_,z_]:=s CauchyBasisS[s,lf,k,z];
CauchyInverseBasis[s_?SignQ,lf_?CircleDomainQ,k_,z_]:=s CauchyBasis[s,lf,k,z];

CauchyInverseBasis[lf_?CircleDomainQ,k_,z_]/;Abs[MapToCircle[lf,z]]<=1.:=CauchyInverseBasis[+1,lf,k,z];
CauchyInverseBasis[lf_?CircleDomainQ,k_,z_]/;Abs[MapToCircle[lf,z]]>1.:=CauchyInverseBasis[-1,lf,k,z];



FPCauchyBasis[s_?SignQ,f_?FunQ,k_,g_?FunQ]:=FPCauchyBasis[s,f//Domain,k,g];

FPCauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,lf_?FunQ]:=Fun[#,lf//Domain]&/@CauchyBasis[s,d,i;;j,lf//Points];

CauchyMatrix[s_?SignQ,lf_LFun?ScalarFunQ,lf2_?FunQ]:=Transpose[(FiniteValues/@FPCauchyBasis[s,lf,Span@@(lf//FFT//IndexRange),lf2])].FiniteTransformMatrix[lf];

CauchyMatrix[s_?SignQ,f_LFun]:=CauchyMatrix[s,f,f];


FastCauchy[lf_LFun]:=Module[{fft,pfft,mfft,inf,infv,z,zc},
fft=lf//FFT;
pfft=ChopDrop[fft//NonNegativeShiftList,$MachineTolerance];
mfft=ChopDrop[fft//NegativeShiftList,$MachineTolerance];
inf=MapToCircle[lf,\[Infinity]];
infv=MapDot[If[#//NZeroQ,1,inf^#]&,If[Abs[inf]>=1,mfft,pfft]];
Function[z,
zc=MapToCircle[lf,z];
If[Abs[zc]>=1,
-MapDot[zc^#&,mfft],
MapDot[If[#//NZeroQ,1,zc^#]&,pfft]
]-infv]
];
FastCauchy[lfv:{__LFun}]:=Module[{CFv},
CFv=FastCauchy/@lfv;
Function[z,
(#[z]&/@CFv)//Total
]
]


CauchyInverseInverseFunction[s_?SignQ,lfu_LFun?UnitCircleFunQ,z_]:=Module[{rts,prts,mrts},rts=ComplexRoots[CauchyInverse[s,lfu]-z];prts=Select[rts,(Abs[#1])^s<=1&];Which[Length[prts]==1,First[prts],True,prts]]
CauchyInverseInverseFunction[lf_LFun,z_]:=Join[{CauchyInverseInverseFunction[+1,lf,z]},{CauchyInverseInverseFunction[-1,lf,z]}]//Flatten//If[Length[#]==1,First[#],#]&
CauchyInverseInverseFunction[s_?SignQ,lf_LFun,z_]:=
MapFromCircle[lf,CauchyInverseInverseFunction[s,lf//ToUnitCircle,z+s Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]]]];

CauchyInverseFunction[sf_LFun,z_]:=CauchyInverseInverseFunction[-I (sf//Hilbert),z];
StieljesInverseFunction[sf_LFun,z_]:=CauchyInverseFunction[sf,z/ (-2 \[Pi]\[NonBreakingSpace]I)];



CauchyD[lf_LFun,z_List]:=CauchyD[lf,#]&/@z;
CauchyD[s_?SignQ,lf_LFun,z_List]:=CauchyD[s,lf,#]&/@z;


CauchyD[lf_LFun,z_]:=Cauchy[lf',z];
CauchyInverseD[lf_LFun,z_]:=CauchyInverse[lf',z];
CauchyInverseD[2][lf_LFun,z_]:=CauchyInverse[lf'',z];
BoundedCauchyInverseD[lf_LFun,z_]:=CauchyInverseD[lf,z];
BoundedCauchyInverseD[k_][lf_LFun,z_]:=CauchyInverseD[k][lf,z];


DomainIntegrate2[lfm0:LFun[_,RealLine]]:=4 \[Pi] LinearSolve[LaurentMatrix[Fun[(1+#)^2&,UnitCircle],lfm0//FFT//IndexRange],lfm0//FFT][[-1]];

CauchyIntegralS[+1,lfm0:LFun[_,RealLine],z_]:=-2 I MapDot[(MapToCircle[RealLine,z]^#-(-1)^#)/#&,LinearSolve[LaurentMatrix[Fun[(1+#)^2&,UnitCircle],lfm0//FFT//IndexRange],lfm0//FFT]//NonNegativeList]+DomainIntegrate2[lfm0] 1/(2 \[Pi] I) (-Log[I+z]);
CauchyIntegralS[-1,lfm0:LFun[_,RealLine],z_]:=2 I MapDot[(MapToCircle[RealLine,z]^-#-(-1)^#)/-#&,LinearSolve[LaurentMatrix[Fun[(1+#)^2&,UnitCircle],lfm0//FFT//IndexRange],lfm0//FFT]//NegativeList//Reverse//Rest]+DomainIntegrate2[lfm0] 1/(2 \[Pi] I) (\[Pi] I -Log[I-z]);
CauchyInverseIntegralS[s_?SignQ,lfm0:LFun[_,RealLine],z_]:=s CauchyIntegralS[s,lfm0,z];


CauchyIntegral[lfm0:LFun[_,RealLine],z_?(Im[#]>0&)]:=CauchyIntegralS[+1,lfm0,z];
CauchyIntegral[lfm0:LFun[_,RealLine],z_?(Im[#]<0&)]:=CauchyIntegralS[-1,lfm0,z];
CauchyIntegral[s_?SignQ,lfm0:LFun[_,RealLine],z_]:=CauchyIntegralS[s,lfm0,z];

CauchyInverseIntegral[lfm0:LFun[_,RealLine],z_?(Im[#]>0&)]:=CauchyInverseIntegralS[+1,lfm0,z];
CauchyInverseIntegral[lfm0:LFun[_,RealLine],z_?(Im[#]<0&)]:=CauchyInverseIntegralS[-1,lfm0,z];
CauchyInverseIntegral[s_?SignQ,lfm0:LFun[_,RealLine],z_]:=CauchyInverseIntegralS[s,lfm0,z];


End[];
EndPackage[];
